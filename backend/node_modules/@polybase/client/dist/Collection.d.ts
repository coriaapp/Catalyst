import { CollectionRecord, CollectionRecordResponse } from './Record';
import { Query } from './Query';
import { SubscriptionFn, SubscriptionErrorFn } from './Subscription';
import { Client } from './Client';
import { QueryValue, CollectionMeta, CollectionList, QueryWhereOperator, CallArgs } from './types';
import { Collection as ASTCollection } from '@polybase/polylang/dist/ast';
export type QuerySnapshotRegister<T> = (q: Query<T>, fn: SubscriptionFn<CollectionList<T>>, errFn?: SubscriptionErrorFn) => (() => void);
export declare class Collection<T> {
    id: string;
    private querySubs;
    private recordSubs;
    private meta?;
    private client;
    private astCache?;
    constructor(id: string, client: Client);
    /**
     * @deprecated You do not need to call load()
     */
    load: () => Promise<void>;
    getMeta: () => Promise<CollectionMeta>;
    getAST: () => Promise<ASTCollection>;
    name(): string;
    validate: (data: Partial<T>) => Promise<boolean>;
    isReadPubliclyAccessible: () => Promise<boolean>;
    isCallPubliclyAccessible: (methodName: string) => Promise<boolean>;
    private isCollectionPubliclyAccessible;
    create: (args?: CallArgs) => Promise<CollectionRecordResponse<T>>;
    get: () => Promise<CollectionList<T>>;
    record: (id: string) => CollectionRecord<T>;
    /**
     * @deprecated use .record(id: string)
     */
    doc: (id: string) => CollectionRecord<T>;
    where: (field: string, op: QueryWhereOperator, value: QueryValue) => Query<T>;
    sort: (field: string, direction?: 'asc' | 'desc') => Query<T>;
    limit: (limit: number) => Query<T>;
    onSnapshot: (fn: SubscriptionFn<CollectionList<T>>, errFn?: SubscriptionErrorFn) => () => void;
    after: (cursor: string) => Query<T>;
    before: (cursor: string) => Query<T>;
    key: () => string;
    private createQuery;
    private onQuerySnapshotRegister;
    private onRecordSnapshotRegister;
}
//# sourceMappingURL=Collection.d.ts.map