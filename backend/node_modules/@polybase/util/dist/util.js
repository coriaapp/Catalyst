"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = exports.parseEncrypedData = exports.stringifyEncryptedData = exports.decodeFromString = exports.encodeToString = exports.addPublicKeyPrefix = exports.stripPublicKeyPrefix = exports.isNullish = exports.stringifiableToHex = void 0;
var bytes_1 = require("@ethersproject/bytes");
var tweetnacl_util_1 = require("tweetnacl-util");
function stringifiableToHex(value) {
    return (0, bytes_1.hexlify)(Buffer.from(JSON.stringify(value)));
}
exports.stringifiableToHex = stringifiableToHex;
function isNullish(value) {
    return value === null || value === undefined;
}
exports.isNullish = isNullish;
function stripPublicKeyPrefix(publicKey) {
    if (publicKey.byteLength % 32 === 0)
        return publicKey;
    return publicKey.slice(1);
}
exports.stripPublicKeyPrefix = stripPublicKeyPrefix;
function addPublicKeyPrefix(publicKey) {
    if (publicKey.byteLength === 64)
        return Buffer.concat([Buffer.from([0x4]), publicKey]);
    return publicKey;
}
exports.addPublicKeyPrefix = addPublicKeyPrefix;
function encodeToString(data, encoding) {
    if (encoding === 'hex')
        return (0, bytes_1.hexlify)(data);
    if (encoding === 'utf8')
        return (0, tweetnacl_util_1.encodeUTF8)(data);
    if (encoding === 'base64')
        return (0, tweetnacl_util_1.encodeBase64)(data);
    throw new Error('Invalid encoding, must be either hex, utf8 or base64');
}
exports.encodeToString = encodeToString;
function decodeFromString(data, encoding) {
    if (encoding === 'hex') {
        if (!data.startsWith('0x')) {
            return (0, bytes_1.arrayify)("0x".concat(data));
        }
        return (0, bytes_1.arrayify)(data);
    }
    if (encoding === 'utf8')
        return (0, tweetnacl_util_1.decodeUTF8)(data);
    if (encoding === 'base64')
        return (0, tweetnacl_util_1.decodeBase64)(data);
    throw new Error('Invalid encoding, must be either hex, utf8 or base64');
}
exports.decodeFromString = decodeFromString;
function stringifyEncryptedData(data, encoding) {
    if (encoding === void 0) { encoding = 'hex'; }
    var obj = {};
    Object.keys(data).forEach(function (key) {
        obj[key] = typeof data[key] === 'string' ? data[key] : encodeToString(data[key], encoding);
    });
    var str = JSON.stringify(obj);
    var buf = decodeFromString(str, 'utf8');
    return encodeToString(buf, encoding);
}
exports.stringifyEncryptedData = stringifyEncryptedData;
function parseEncrypedData(str, encoding) {
    if (encoding === void 0) { encoding = 'hex'; }
    var buf = decodeFromString(str, encoding);
    var data = JSON.parse(encodeToString(buf, 'utf8'));
    var obj = {};
    Object.keys(data).forEach(function (key) {
        if (key === 'version')
            obj[key] = data[key];
        else
            obj[key] = decodeFromString(data[key], encoding);
    });
    return obj;
}
exports.parseEncrypedData = parseEncrypedData;
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}
exports.assert = assert;
//# sourceMappingURL=util.js.map